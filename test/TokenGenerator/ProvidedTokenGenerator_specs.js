/* global fetch, describe, it, afterEach */
global.FormData = require('form-data');
import { expect } from 'chai';
import fetchMock from 'fetch-mock';
import oauthClientCredentialsMock from '../mock/oauthClientCredentials';
import { TokenStorage, ProvidedTokenGenerator } from '../../src';
import Storage from '../mock/mockStorage';

const providedToken = oauthClientCredentialsMock.access_token;

describe('ProvidedTokenGenerator tests', () => {
  afterEach(fetchMock.restore);

  it('test generateToken method', () => {
    const tokenGenerator = new ProvidedTokenGenerator(providedToken);
    const token = tokenGenerator.generateToken();

    expect(token).to.be.an.instanceOf(Promise);

    return Promise.all([
      expect(token).to.eventually.be.an('object'),
      expect(token.then(a => a.access_token)).to.eventually.equals(
        oauthClientCredentialsMock.access_token
      ),
    ]);
  });

  it('test that refreshToken refresh the token ;)', () => {
    const tokenGenerator = new ProvidedTokenGenerator(providedToken);
    const refreshedToken = tokenGenerator.refreshToken();

    expect(refreshedToken).to.be.an.instanceOf(Promise);

    return Promise.all([
      expect(refreshedToken).to.eventually.be.an('object'),
      expect(refreshedToken.then(a => a.access_token)).to.eventually.equals(
        oauthClientCredentialsMock.access_token
      ),
    ]);
  });

  it('test get token without generating it', () => {
    const tokenGenerator = new ProvidedTokenGenerator(providedToken);
    const oauth = new TokenStorage(tokenGenerator, new Storage());
    const autogeneratedToken = oauth.getAccessToken();
    expect(autogeneratedToken).to.be.an.instanceOf(Promise);
    return Promise.all([
      expect(autogeneratedToken.then()).to.eventually.equals(
        oauthClientCredentialsMock.access_token
      ),
    ]);
  });

  it('test generate and get token', () => {
    const tokenGenerator = new ProvidedTokenGenerator(providedToken);
    const oauth = new TokenStorage(tokenGenerator, new Storage());

    const tokenPromise = oauth.generateToken();
    expect(tokenPromise).to.be.an.instanceOf(Promise);

    return tokenPromise.then(token => {
      expect(token).to.deep.equals({
        access_token: oauthClientCredentialsMock.access_token,
      });

      const autogeneratedToken = oauth.getAccessToken();
      expect(autogeneratedToken).to.be.an.instanceOf(Promise);
      return expect(autogeneratedToken).to.eventually.equals(
        oauthClientCredentialsMock.access_token
      );
    });
  });

  it('refresh the token if the second parameter is set', () => {
    const newToken = { a: 'new token' };
    fetchMock.mock('^http://foo.bar', newToken);

    const refreshFunc = () =>
      fetch('http://foo.bar', {
        method: 'POST',
      }).then(response => {
        if (response.status !== 200) {
          return response
            .json()
            .then(responseData => Promise.reject(responseData));
        }

        return response.json();
      });

    const tokenGenerator = new ProvidedTokenGenerator(
      providedToken,
      refreshFunc
    );

    return expect(tokenGenerator.refreshToken()).to.eventually.deep.equals(
      newToken
    );
  });
});
