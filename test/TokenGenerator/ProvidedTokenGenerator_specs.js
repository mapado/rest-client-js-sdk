/* global fetch, describe, it, afterEach */
global.FormData = require('form-data');
import {
  expect,
} from 'chai';
import fetchMock from 'fetch-mock';
import oauthClientCredentialsMock from '../mock/oauthClientCredentials';
import { TokenStorage, ProvidedTokenGenerator } from '../../src';
import Storage from '../mock/mockStorage';

const providedToken = oauthClientCredentialsMock.access_token;

describe('ProvidedTokenGenerator tests', () => {
  afterEach(fetchMock.restore);

  it('test generateToken method', () => {
    const tokenGenerator = new ProvidedTokenGenerator(providedToken);
    const token = tokenGenerator.generateToken();

    expect(token).to.be.an.instanceOf(Promise);

    return Promise.all([
      expect(token).to.be.an.object,
      expect(token.then(a => a.access_token))
        .to.eventually.equals(oauthClientCredentialsMock.access_token),
    ]);
  });

  it('test that refreshToken refresh the token ;)', () => {
    const tokenGenerator = new ProvidedTokenGenerator(providedToken);
    const refreshedToken = tokenGenerator.refreshToken();

    expect(refreshedToken).to.be.an.instanceOf(Promise);

    return Promise.all([
      expect(refreshedToken).to.eventually.be.an.object,
      expect(refreshedToken.then(a => a.access_token))
        .to.eventually.equals(oauthClientCredentialsMock.access_token),
    ]);
  });

  it('test get token without generating it', () => {
    const tokenGenerator = new ProvidedTokenGenerator(providedToken);
    const oauth = new TokenStorage(tokenGenerator, new Storage());
    const autogeneratedToken = oauth.getAccessToken();
    expect(autogeneratedToken).to.be.an.instanceOf(Promise);
    return Promise.all([
      expect(autogeneratedToken.then())
        .to.eventually.equals(oauthClientCredentialsMock.access_token),
    ]);
  });

  it('test generate and get token', () => {
    const tokenGenerator = new ProvidedTokenGenerator(providedToken);
    const oauth = new TokenStorage(tokenGenerator, new Storage());

    const tokenPromise = oauth.generateToken();
    expect(tokenPromise).to.be.an.instanceOf(Promise);

    return tokenPromise
      .then(token => {
        expect(token)
          .to.deep.equals({ access_token: oauthClientCredentialsMock.access_token });

        const autogeneratedToken = oauth.getAccessToken();
        expect(autogeneratedToken).to.be.an.instanceOf(Promise);
        return expect(autogeneratedToken)
          .to.eventually.equals(oauthClientCredentialsMock.access_token);
      })
    ;
  });

  it('refresh the token if the second parameter is set', () => {
    const newToken = { a: 'new token' };
    fetchMock
      .mock('^http://foo.bar', newToken)
      .getMock()
    ;

    const refreshFunc = () => (
      fetch('http://foo.bar', {
        method: 'POST',
      })
        .then((response) => {
          if (response.status !== 200) {
            return response.json()
              .then(responseData => Promise.reject(responseData));
          }

          return response.json();
        })
    );

    const tokenGenerator = new ProvidedTokenGenerator(
      providedToken, refreshFunc,
    );

    return expect(tokenGenerator.refreshToken()).to.eventually.deep.equals(newToken)
    ;
  });
});
